// -*- Metal -*-
//===-- metal_texture -----------------------------------------------------===//
// Copyright (c) 2014-2020 Apple Inc. All rights reserved
//===----------------------------------------------------------------------===//

#ifndef __METAL_TEXTURE
#define __METAL_TEXTURE

#if defined(__HAVE_ARRAY__)
#include <metal_array>
#endif
#if defined(__HAVE_IMAGEBLOCKS__)
#include <metal_imageblocks>
#endif

#pragma METAL internals : enable
namespace metal
{
enum class coord
{
  normalized = __METAL_COORD_NORMALIZED__,
  pixel = __METAL_COORD_PIXEL__
};
enum class filter
{
  nearest = __METAL_FILTER_NEAREST__,
  linear = __METAL_FILTER_LINEAR__,
#if defined(__HAVE_BICUBIC_FILTERING__)
  bicubic = __METAL_FILTER_BICUBIC__
#endif
};
enum class s_address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
#if defined(__HAVE_BORDER_COLOR__)
  clamp_to_border = __METAL_ADDRESS_CLAMP_TO_BORDER__
#endif
};
enum class t_address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
#if defined(__HAVE_BORDER_COLOR__)
  clamp_to_border = __METAL_ADDRESS_CLAMP_TO_BORDER__
#endif
};
enum class r_address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
#if defined(__HAVE_BORDER_COLOR__)
  clamp_to_border = __METAL_ADDRESS_CLAMP_TO_BORDER__
#endif
};
enum class address
{
  clamp_to_zero = __METAL_ADDRESS_CLAMP_TO_ZERO__,
  clamp_to_edge = __METAL_ADDRESS_CLAMP_TO_EDGE__,
  repeat = __METAL_ADDRESS_REPEAT__,
  mirrored_repeat = __METAL_ADDRESS_MIRRORED_REPEAT__,
#if defined(__HAVE_BORDER_COLOR__)
  clamp_to_border = __METAL_ADDRESS_CLAMP_TO_BORDER__
#endif
};
enum class mip_filter
{
  none = __METAL_MIP_FILTER_NONE__,
  nearest = __METAL_MIP_FILTER_NEAREST__,
  linear = __METAL_MIP_FILTER_LINEAR__
};
enum class compare_func
{
#if defined(__HAVE_NONE_COMPARE_FUNCTION__)
  none = __METAL_COMPARE_FUNC_NONE__,
#endif
  less = __METAL_COMPARE_FUNC_LESS__,
  less_equal = __METAL_COMPARE_FUNC_LESS_EQUAL__,
  greater = __METAL_COMPARE_FUNC_GREATER__,
  greater_equal = __METAL_COMPARE_FUNC_GREATER_EQUAL__,
  equal = __METAL_COMPARE_FUNC_EQUAL__,
  not_equal = __METAL_COMPARE_FUNC_NOT_EQUAL__,
#if defined(__HAVE_ALWAYS_NEVER_COMPARE_FUNCTION__)
  always = __METAL_COMPARE_FUNC_ALWAYS__,
  never = __METAL_COMPARE_FUNC_NEVER__
#endif
};
enum class mag_filter
{
  nearest = __METAL_MAG_FILTER_NEAREST__,
  linear = __METAL_MAG_FILTER_LINEAR__,
#if defined(__HAVE_BICUBIC_FILTERING__)
  bicubic = __METAL_MAG_FILTER_BICUBIC__
#endif
};
enum class min_filter
{
  nearest = __METAL_MIN_FILTER_NEAREST__,
  linear = __METAL_MIN_FILTER_LINEAR__,
#if defined(__HAVE_BICUBIC_FILTERING__)
  bicubic = __METAL_MIN_FILTER_BICUBIC__
#endif
};

struct __max_anisotropy
{
  METAL_FUNC constexpr explicit __max_anisotropy(int v) thread
      : value(v - 1) // Given value 1 to 16 is stored as 4 bits 0 to 15.
  {
  }
  uchar value : 4;
};
struct __lod_clamp
{
  METAL_FUNC constexpr explicit __lod_clamp(float min, float max) thread
      : bits((convert(max) << 16) | convert(min))
  {
  }
  uint bits;

private:
  METAL_FUNC static constexpr float clamp(float x, float absmax)
  {
    return (x > absmax) ? absmax : (x < -absmax) ? -absmax : x;
  }
  METAL_FUNC static constexpr uint convert(float x)
  {
    return as_type<ushort>(static_cast<half>(__builtin_isfinite(x) ? clamp(x, HALF_MAX) : x));
  }
};

#if defined(__HAVE_ANISOTROPY_LOD_MIN_MAX__)
using max_anisotropy = __max_anisotropy;
using lod_clamp = __lod_clamp;
#endif

#if defined(__HAVE_BORDER_COLOR__)
enum class border_color
{
  transparent_black = __METAL_BORDER_COLOR_TRANSPARENT_BLACK__,
  opaque_black = __METAL_BORDER_COLOR_OPAQUE_BLACK__,
  opaque_white = __METAL_BORDER_COLOR_OPAQUE_WHITE__
};
#endif

#if defined(__HAVE_SAMPLER_REDUCTION__)
enum class reduction
{
  weighted_average = __METAL_REDUCTION_WEIGHTED_AVERAGE__,
  minimum = __METAL_REDUCTION_MINIMUM__,
  maximum = __METAL_REDUCTION_MAXIMUM__
};
#endif

// Metal 1.1 s2.6: Samplers.
struct sampler
{
#if defined(__HAVE_OPERATOR_ADDRESSOF_DELETED__)
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread sampler &operator&() const thread = delete;
#endif
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant sampler &operator&() const constant = delete;
#endif
#endif

public:
  METAL_FUNC constexpr sampler() thread : val(build())
  {
  }
  template <typename... Ts>
  METAL_FUNC constexpr sampler(Ts... t) thread : val(build(t...))
  {
  }
  METAL_FUNC constexpr sampler() constant : val(build())
  {
  }
  template <typename... Ts>
  METAL_FUNC constexpr sampler(Ts... t) constant : val(build(t...))
  {
  }
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler() ray_data : val(build())
  {
  }
  template <typename... Ts>
  METAL_FUNC constexpr sampler(Ts... t) ray_data : val(build(t...))
  {
  }
#endif

  METAL_FUNC constexpr sampler(const thread sampler &) thread = default;
  METAL_FUNC constexpr sampler(const constant sampler &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC constexpr sampler(const device sampler &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const ray_data sampler &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC constexpr sampler(const object_data sampler &) thread = default;
#endif
  METAL_FUNC constexpr sampler(const thread sampler &) constant = default;
  METAL_FUNC constexpr sampler(const constant sampler &) constant = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC constexpr sampler(const device sampler &) constant = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const ray_data sampler &) constant = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC constexpr sampler(const object_data sampler &) constant = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const thread sampler &) ray_data = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const constant sampler &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const device sampler &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const ray_data sampler &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC constexpr sampler(const object_data sampler &) ray_data = default;
#endif
#endif

#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const thread sampler &) thread = default;
#else
  thread sampler &operator=(const thread sampler &) thread = delete;
#endif
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const constant sampler &) thread = default;
#else
  thread sampler &operator=(const constant sampler &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const device sampler &) thread = default;
#else
  thread sampler &operator=(const device sampler &) thread = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const ray_data sampler &) thread = default;
#else
  thread sampler &operator=(const ray_data sampler &) thread = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC thread sampler &operator=(const object_data sampler &) thread = default;
#else
  thread sampler &operator=(const object_data sampler &) thread = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const thread sampler &) device = default;
#else
  device sampler &operator=(const thread sampler &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const constant sampler &) device = default;
#else
  device sampler &operator=(const constant sampler &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const device sampler &) device = default;
#else
  device sampler &operator=(const device sampler &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const ray_data sampler &) device = default;
#else
  device sampler &operator=(const ray_data sampler &) device = delete;
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC device sampler &operator=(const object_data sampler &) device = default;
#else
  device sampler &operator=(const object_data sampler &) device = delete;
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const thread sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const thread sampler &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const constant sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const constant sampler &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const device sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const device sampler &) ray_data = delete;
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const ray_data sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const ray_data sampler &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC ray_data sampler &operator=(const object_data sampler &) ray_data = default;
#else
  ray_data sampler &operator=(const object_data sampler &) ray_data = delete;
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const thread sampler &) object_data = default;
#else
  object_data sampler &operator=(const thread sampler &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const constant sampler &) object_data = default;
#else
  object_data sampler &operator=(const constant sampler &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const device sampler &) object_data = default;
#else
  object_data sampler &operator=(const device sampler &) object_data = delete;
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const ray_data sampler &) object_data = default;
#else
  object_data sampler &operator=(const ray_data sampler &) object_data = delete;
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_ARRAYS_OF_SAMPLERS__)
  METAL_FUNC object_data sampler &operator=(const object_data sampler &) object_data = default;
#else
  object_data sampler &operator=(const object_data sampler &) object_data = delete;
#endif
#endif

private:
  __metal_sampler_t val;

private:
  // Values to help calculate offsets.
  constexpr const static constant unsigned s_address_bits  =  3;   // bits[2:0]   s_address mode
  constexpr const static constant unsigned t_address_bits  =  3;   // bits[5:3]   t_address mode
  constexpr const static constant unsigned r_address_bits  =  3;   // bits[8:6]   r_address mode
  constexpr const static constant unsigned mag_filter_bits =  2;   // bits[10:9]  mag filter mode
  constexpr const static constant unsigned min_filter_bits =  2;   // bits[12:11] min filter mode
  constexpr const static constant unsigned mip_filter_bits =  2;   // bits[14:13] mip filter mode
  constexpr const static constant unsigned normalized_bits =  1;   // bits[15:15] normalized mode
  constexpr const static constant unsigned compare_bits    =  4;   // bits[19:16] compare func
  constexpr const static constant unsigned anisotropy_bits =  4;   // bits[23:20] max anisotropy level
  constexpr const static constant unsigned lod_clamp_bits  = 32;   // bits[39:24] lod min value
                                                                   // bits[55:40] lod max value
  constexpr const static constant unsigned border_color_bits =  2; // bits[57:56] border_color
#if defined(__HAVE_SAMPLER_REDUCTION__)
  constexpr const static constant unsigned reduction_bits    =  2; // bits[59:58] reduction
                                                                   // bits[62:60] reserved
#endif
  constexpr const static constant unsigned marker_bit        = 63; // bits[63:63] constant sampler indicator.

  constexpr const static constant unsigned s_address_base    = 0;
  constexpr const static constant unsigned t_address_base    = s_address_base  + s_address_bits;
  constexpr const static constant unsigned r_address_base    = t_address_base  + t_address_bits;
  constexpr const static constant unsigned mag_filter_base   = r_address_base  + r_address_bits;
  constexpr const static constant unsigned min_filter_base   = mag_filter_base + mag_filter_bits;
  constexpr const static constant unsigned mip_filter_base   = min_filter_base + min_filter_bits;
  constexpr const static constant unsigned normalized_base   = mip_filter_base + mip_filter_bits;
  constexpr const static constant unsigned compare_base      = normalized_base + normalized_bits;
  constexpr const static constant unsigned anisotropy_base   = compare_base    + compare_bits;
  constexpr const static constant unsigned lod_clamp_base    = anisotropy_base + anisotropy_bits;
  constexpr const static constant unsigned border_color_base = lod_clamp_base + lod_clamp_bits;
#if defined(__HAVE_SAMPLER_REDUCTION__)
  constexpr const static constant unsigned reduction_base    = border_color_base + border_color_bits;
#endif

  constexpr const static constant ulong s_address_mask    = ((1UL << s_address_bits   ) - 1) << s_address_base;
  constexpr const static constant ulong t_address_mask    = ((1UL << t_address_bits   ) - 1) << t_address_base;
  constexpr const static constant ulong r_address_mask    = ((1UL << r_address_bits   ) - 1) << r_address_base;
  constexpr const static constant ulong mag_filter_mask   = ((1UL << mag_filter_bits  ) - 1) << mag_filter_base;
  constexpr const static constant ulong min_filter_mask   = ((1UL << min_filter_bits  ) - 1) << min_filter_base;
  constexpr const static constant ulong mip_filter_mask   = ((1UL << mip_filter_bits  ) - 1) << mip_filter_base;
  constexpr const static constant ulong normalized_mask   = ((1UL << normalized_bits  ) - 1) << normalized_base;
  constexpr const static constant ulong compare_mask      = ((1UL << compare_bits     ) - 1) << compare_base;
  constexpr const static constant ulong anisotropy_mask   = ((1UL << anisotropy_bits  ) - 1) << anisotropy_base;
  constexpr const static constant ulong lod_clamp_mask    = ((1UL << lod_clamp_bits   ) - 1) << lod_clamp_base;
  constexpr const static constant ulong border_color_mask = ((1UL << border_color_bits) - 1) << border_color_base;
#if defined(__HAVE_SAMPLER_REDUCTION__)
  constexpr const static constant ulong reduction_mask    = ((1UL << reduction_bits   ) - 1) << reduction_base;
#endif

#if defined(__HAVE_ALWAYS_NEVER_COMPARE_FUNCTION__)
  constexpr const static constant compare_func default_compare_func = compare_func::never;
#else
  constexpr const static constant compare_func default_compare_func = compare_func::none;
#endif
  constexpr const static constant auto default_anisotropy = __max_anisotropy(1);
  constexpr const static constant auto default_lod_clamp = __lod_clamp(0.0f, FLT_MAX);

  static constexpr ulong build()
  {
    return (ulong(1) << marker_bit) |
           (ulong(default_lod_clamp.bits) << lod_clamp_base) |
           (ulong(default_anisotropy.value) << anisotropy_base) |
           (ulong(default_compare_func) << compare_base) |
           (ulong(address::clamp_to_edge) << s_address_base) |
           (ulong(address::clamp_to_edge) << t_address_base) |
           (ulong(address::clamp_to_edge) << r_address_base);
  }

  template <typename... Ts>
  static constexpr ulong build(coord mode, Ts... t)
  {
    return (ulong(mode) << normalized_base) | (build(t...) & ~normalized_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(s_address mode, Ts... t)
  {
    return (ulong(mode) << s_address_base) | (build(t...) & ~s_address_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(t_address mode, Ts... t)
  {
    return (ulong(mode) << t_address_base) | (build(t...) & ~t_address_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(r_address mode, Ts... t)
  {
    return (ulong(mode) << r_address_base) | (build(t...) & ~r_address_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(address mode, Ts... t)
  {
    return (ulong(mode) << s_address_base) |
           (ulong(mode) << t_address_base) |
           (ulong(mode) << r_address_base) |
           (build(t...) & ~(s_address_mask | t_address_mask | r_address_mask));
  }

  template <typename... Ts>
  static constexpr ulong build(mag_filter mode, Ts... t)
  {
    return (ulong(mode) << mag_filter_base) | (build(t...) & ~mag_filter_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(min_filter mode, Ts... t)
  {
    return (ulong(mode) << min_filter_base) | (build(t...) & ~min_filter_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(filter mode, Ts... t)
  {
    return (ulong(mode) << mag_filter_base) |
           (ulong(mode) << min_filter_base) |
           (build(t...) & ~(mag_filter_mask | min_filter_mask));
  }

  template <typename... Ts>
  static constexpr ulong build(mip_filter mode, Ts... t)
  {
    return (ulong(mode) << mip_filter_base) | (build(t...) & ~mip_filter_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(compare_func mode, Ts... t)
  {
    return (ulong(mode) << compare_base) | (build(t...) & ~compare_mask);
  }

#if defined(__HAVE_ANISOTROPY_LOD_MIN_MAX__)
  template <typename... Ts>
  static constexpr ulong build(max_anisotropy aniso, Ts... t)
  {
    return (ulong(aniso.value) << anisotropy_base) | (build(t...) & ~anisotropy_mask);
  }

  template <typename... Ts>
  static constexpr ulong build(lod_clamp lod, Ts... t)
  {
    return (ulong(lod.bits) << lod_clamp_base) | (build(t...) & ~lod_clamp_mask);
  }
#endif

#if defined(__HAVE_BORDER_COLOR__)
  template <typename... Ts>
  static constexpr ulong build(border_color mode, Ts... t)
  {
    return (ulong(mode) << border_color_base) | (build(t...) & ~border_color_mask);
  }
#endif

#if defined(__HAVE_SAMPLER_REDUCTION__)
  template <typename... Ts>
  static constexpr ulong build(reduction mode, Ts... t)
  {
    return (ulong(mode) << reduction_base) | (build(t...) & ~reduction_mask);
  }
#endif

private:
  template <typename T, access a, typename _Enable>
  friend struct _texture1d_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texture1d_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texture2d_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texture2d_gather;
  template <typename T, access a, typename _Enable>
  friend struct _texture2d_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texture2d_array_gather;
  template <typename T, access a, typename _Enable>
  friend struct _texture3d_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texturecube_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texturecube_gather;
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
  template <typename T, access a, typename _Enable>
  friend struct _texturecube_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _texturecube_array_gather;
#endif
  template <typename T, access a, typename _Enable>
  friend struct _depth2d_sample;
  template <typename T, access a, typename _Enable>
  friend struct _depth2d_gather;
  template <typename T, access a, typename _Enable>
  friend struct _depth2d_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _depth2d_array_gather;
  template <typename T, access a, typename _Enable>
  friend struct _depthcube_sample;
  template <typename T, access a, typename _Enable>
  friend struct _depthcube_gather;
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
  template <typename T, access a, typename _Enable>
  friend struct _depthcube_array_sample;
  template <typename T, access a, typename _Enable>
  friend struct _depthcube_array_gather;
#endif
};

template <typename T>
struct _is_color_texture_channel_impl : bool_constant<__is_metal_color_texture_channel(T)>
{
};

template <typename T>
struct is_color_texture_channel : _is_color_texture_channel_impl<remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename T>
constexpr constant bool is_color_texture_channel_v = is_color_texture_channel<T>::value;
#endif

template <typename T>
struct _is_depth_texture_channel_impl : bool_constant<__is_metal_depth_texture_channel(T)>
{
};

template <typename T>
struct is_depth_texture_channel : _is_depth_texture_channel_impl<remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename T>
constexpr constant bool is_depth_texture_channel_v = is_depth_texture_channel<T>::value;
#endif

#if defined(__HAVE_SPARSE_TEXTURES__)
template <typename T, typename _E = typename enable_if<is_color_texture_channel<make_scalar_t<T>>::value || is_depth_texture_channel<make_scalar_t<T>>::value>::type>
struct sparse_color
{
public:
  METAL_FUNC constexpr sparse_color(T value, bool resident) thread
      : color_value(value), from_resident_pages(resident)
  {
  }

  // Indicates whether all memory addressed to retrieve the value was mapped.
  METAL_FUNC constexpr bool resident() const thread
  {
    return from_resident_pages;
  }
  METAL_FUNC constexpr T const value() const thread
  {
    return color_value;
  }

private:
  T color_value;
  ulong from_resident_pages : 1;
  ulong reserved : 63;
};
#endif

struct bias
{
  METAL_FUNC constexpr bias(float value) thread
      : value(value)
  {
  }
  float value;
};

struct level
{
  METAL_FUNC constexpr level(float lod) thread
      : lod(lod)
  {
  }
  float lod;
};

#if defined(__HAVE_MIN_LOD_CLAMP__)
struct min_lod_clamp
{
  METAL_FUNC constexpr min_lod_clamp(float value) thread
      : value(value)
  {
  }
  float value;
};
#endif

// To allow level to be used in constant argument checks.
template <>
struct _constarg_traits<level>
{
  constexpr static METAL_INTERNAL bool check(level l)
  {
    return _constarg_traits<float>::check(l.lod);
  }
};

struct gradient2d
{
  METAL_FUNC constexpr gradient2d(float2 dPdx, float2 dPdy) thread
      : dPdx(dPdx), dPdy(dPdy)
  {
  }
  float2 dPdx;
  float2 dPdy;
};

struct gradient3d
{
  METAL_FUNC constexpr gradient3d(float3 dPdx, float3 dPdy) thread
      : dPdx(dPdx), dPdy(dPdy)
  {
  }
  float3 dPdx;
  float3 dPdy;
};

struct gradientcube
{
  METAL_FUNC constexpr gradientcube(float3 dPdx, float3 dPdy) thread
      : dPdx(dPdx), dPdy(dPdy)
  {
  }
  float3 dPdx;
  float3 dPdy;
};

enum class component
{
  x,
  y,
  z,
  w
};

METAL_INTERNAL constexpr bool _is_zero(uint a)
{
  return a == 0;
}
METAL_INTERNAL constexpr bool _is_zero(level a)
{
  return a.lod == 0;
}
#define METAL_ZERO_ARG(A) \
  METAL_ENABLE_IF(_is_zero(A), "'" #A "' argument value must be 0")

#if defined(__HAVE_ZERO_LOD_ARG__)
#define METAL_VALID_LOD_ARG(A) \
  METAL_CONST_ARG(A)           \
  METAL_ZERO_ARG(A)
#else
#define METAL_VALID_LOD_ARG(A)
#endif

#if defined(__HAVE_ZERO_LOD_ARG__)
#define METAL_VALID_LEVEL_ARG(A) \
  METAL_CONST_ARG(A)             \
  METAL_ZERO_ARG(A)
#else
#define METAL_VALID_LEVEL_ARG(A)
#endif

// Metal 1.1 s2.5: Textures.
template <typename T, access a = access::sample, typename _Enable = void>
struct texture1d;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture1d_array;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture2d;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture2d_array;
template <typename T, access a = access::sample, typename _Enable = void>
struct texture3d;
template <typename T, access a = access::sample, typename _Enable = void>
struct texturecube;
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a = access::sample, typename _Enable = void>
struct texturecube_array;
#endif
template <typename T, access a = access::read, typename _Enable = void>
struct texture2d_ms;
#if defined(__HAVE_TEXTURE_2D_MS_ARRAY__)
template <typename T, access a = access::read, typename _Enable = void>
struct texture2d_ms_array;
#endif
#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a = access::read, typename _Enable = void>
struct texture_buffer;
#endif
template <typename T, access a = access::sample, typename _Enable = void>
struct depth2d;
template <typename T, access a = access::sample, typename _Enable = void>
struct depth2d_array;
template <typename T, access a = access::sample, typename _Enable = void>
struct depthcube;
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a = access::sample, typename _Enable = void>
struct depthcube_array;
#endif
template <typename T, access a = access::read, typename _Enable = void>
struct depth2d_ms;
#if defined(__HAVE_DEPTH_2D_MS_ARRAY__)
template <typename T, access a = access::read, typename _Enable = void>
struct depth2d_ms_array;
#endif

#if defined(__HAVE_NULL_TEXTURE__)
// Metal 1.2 s5.10.15: Null Texture Functions.
template <typename T, access a> METAL_FUNC bool is_null_texture(texture1d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture1d_array<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d_array<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texture3d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(texturecube<T, a> tex);
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(texturecube_array<T, a> tex);
#endif
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d_ms<T, a> tex);
#if defined(__HAVE_TEXTURE_2D_MS_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(texture2d_ms_array<T, a> tex);
#endif
#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a> METAL_FUNC bool is_null_texture(texture_buffer<T, a> tex);
#endif
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d_array<T, a> tex);
template <typename T, access a> METAL_FUNC bool is_null_texture(depthcube<T, a> tex);
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(depthcube_array<T, a> tex);
#endif
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d_ms<T, a> tex);
#if defined(__HAVE_DEPTH_2D_MS_ARRAY__)
template <typename T, access a> METAL_FUNC bool is_null_texture(depth2d_ms_array<T, a> tex);
#endif
#endif

#if defined(__HAVE_IMAGEBLOCKS__)
template <typename E, typename T>
struct _is_color_texture_imageblock_slice_storage_valid_impl : bool_constant<__is_metal_color_texture_imageblock_slice_storage_valid(E, T)>
{
};

template <typename E, typename T>
struct is_color_texture_imageblock_slice_storage_valid : _is_color_texture_imageblock_slice_storage_valid_impl<remove_cv_t<E>, remove_cv_t<T>>
{
};
#ifdef __cpp_variable_templates
template <typename E, typename T>
constexpr constant bool is_color_texture_imageblock_slice_storage_valid_v = is_color_texture_imageblock_slice_storage_valid<E, T>::value;
#endif
#endif


template <typename T>
METAL_INTERNAL constexpr bool _is_any_of(T)
{
  return false;
}

template <typename T, typename... Ts>
METAL_INTERNAL constexpr bool _is_any_of(T a, T b, Ts... bs)
{
  return a == b || _is_any_of(a, bs...);
}

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__)
#if !defined(__HAVE_INDIRECT_WRITABLE_TEXTURES__)
#define _is_valid_default_construct(_a) _is_any_of(_a, access::read, access::sample)
#elif !defined(__HAVE_TEXTURE_READWRITE__)
#define _is_valid_default_construct(_a) _is_any_of(_a, access::read, access::sample, access::write)
#else
#define _is_valid_default_construct(_a) _is_any_of(_a, access::read, access::sample, access::write, access::read_write)
#endif
#endif

#if defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
#if !defined(__HAVE_INDIRECT_WRITABLE_TEXTURES__)
#define _is_valid_copy_assign(a) _is_any_of(a, access::read, access::sample)
#elif !defined(__HAVE_TEXTURE_READWRITE__)
#define _is_valid_copy_assign(a) _is_any_of(a, access::read, access::sample, access::write)
#else
#define _is_valid_copy_assign(a) _is_any_of(a, access::read, access::sample, access::write, access::read_write)
#endif
#endif

#define _is_valid_sample(_a) _is_any_of(_a, access::sample)

#if defined(__HAVE_TEXTURE_READWRITE__)
#define _is_valid_read(_a) _is_any_of(_a, access::sample, access::read, access::read_write)
#define _is_valid_write(_a) _is_any_of(_a, access::write, access::read_write)
#else
#define _is_valid_read(_a) _is_any_of(_a, access::sample, access::read)
#define _is_valid_write(_a) _is_any_of(_a, access::write)
#endif

#define _is_valid_gather(_a) _is_any_of(_a, access::sample)

#define _is_valid_ms_access(_a) _is_any_of(_a, access::read)

#define _is_valid_texture_buffer_access(_a) _is_any_of(_a, access::read, access::write, access::read_write)

#define _is_valid_depth_access(_a) _is_any_of(_a, access::sample, access::read)

#if defined(__HAVE_IMAGEBLOCKS__)
#define _is_valid_imageblock_slice_write(_e, _t) (is_color_texture_imageblock_slice_storage_valid_v<_e, _t>)
#endif


template <typename _T>
struct _deleted_operators {
#if defined(__HAVE_OPERATOR_ADDRESSOF_DELETED__)
#if !defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread _deleted_operators &operator&() const thread = delete;
#endif
#endif

#if defined(__HAVE_OPERATOR_COMMA_DELETED__)
  const thread _deleted_operators &operator,(const thread _deleted_operators &) const thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device _deleted_operators &operator,(const device _deleted_operators &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant _deleted_operators &operator,(const constant _deleted_operators &) const thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread _deleted_operators &operator,(const thread _deleted_operators &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device _deleted_operators &operator,(const device _deleted_operators &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant _deleted_operators &operator,(const constant _deleted_operators &) const device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const thread _deleted_operators &operator,(const thread _deleted_operators &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const device _deleted_operators &operator,(const device _deleted_operators &) const constant = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  const constant _deleted_operators &operator,(const constant _deleted_operators &) const constant = delete;
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_sample
{
};

template <typename T, access a>
struct _texture1d_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool *>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_t(derived.t, s.val, coord, false, 0, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_read
{
};

template <typename T, access a>
struct _texture1d_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_read_texture_1d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_write
{
};

template <typename T, access a>
struct _texture1d_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_write_texture_1d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};


template <typename T, access a, typename _Enable = void>
struct _texture1d
{
};

template <typename T, access a>
struct _texture1d<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture1d<T, a>>
  , _texture1d_sample<T, a>
  , _texture1d_read<T, a>
  , _texture1d_write<T, a>
{
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture1d<T, a> &>(*this);
    __metal_fence_texture_1d_t(derived.t);
  }
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_get_width_texture_1d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture1d : _texture1d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture1d'");

  texture1d() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture1d() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture1d() ray_data = delete;
#endif

  METAL_FUNC texture1d(const thread texture1d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const device texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const constant texture1d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d(const object_data texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const thread texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const device texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const constant texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d(const object_data texture1d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const thread texture1d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const device texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const constant texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const object_data texture1d &) ray_data = default;
#endif
#endif

  thread texture1d &operator=(const thread texture1d &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture1d &operator=(const device texture1d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture1d &operator=(const constant texture1d &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture1d &operator=(const ray_data texture1d &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture1d &operator=(const object_data texture1d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d &operator=(const thread texture1d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d &operator=(const device texture1d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d &operator=(const constant texture1d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture1d &operator=(const ray_data texture1d &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture1d &operator=(const object_data texture1d &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const thread texture1d &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const device texture1d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const constant texture1d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const ray_data texture1d &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d &operator=(const object_data texture1d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const thread texture1d &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const device texture1d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const constant texture1d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const ray_data texture1d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture1d &operator=(const object_data texture1d &) object_data = delete;
#endif

private:
  __metal_texture_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d<T, a>);
#endif
  friend struct _texture1d_sample<T, a>;
  friend struct _texture1d_read<T, a>;
  friend struct _texture1d_write<T, a>;
  friend struct _texture1d<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture1d<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture1d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture1d'");

  METAL_FUNC texture1d() thread : t(__metal_get_null_texture_1d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d() constant : t(__metal_get_null_texture_1d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d() ray_data : t(__metal_get_null_texture_1d_t()) {}
#endif

  METAL_FUNC texture1d(const thread texture1d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const device texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const constant texture1d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d(const object_data texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const thread texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const device texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d(const constant texture1d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d(const object_data texture1d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const thread texture1d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const device texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const constant texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const ray_data texture1d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d(const object_data texture1d &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture1d &operator=(const thread texture1d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture1d &operator=(const device texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture1d &operator=(const constant texture1d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture1d &operator=(const ray_data texture1d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture1d &operator=(const object_data texture1d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d &operator=(const thread texture1d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d &operator=(const device texture1d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d &operator=(const constant texture1d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture1d &operator=(const ray_data texture1d &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture1d &operator=(const object_data texture1d &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const thread texture1d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const device texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const constant texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const ray_data texture1d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d &operator=(const object_data texture1d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const thread texture1d &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const device texture1d &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const constant texture1d &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const ray_data texture1d &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d &operator=(const object_data texture1d &) object_data = default;
#endif

private:
  __metal_texture_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d<T, a>);
#endif
  friend struct _texture1d_sample<T, a>;
  friend struct _texture1d_read<T, a>;
  friend struct _texture1d_write<T, a>;
  friend struct _texture1d<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_sample
{
};

template <typename T, access a>
struct _texture1d_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float coord, uint array) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_1d_array_t(derived.t, s.val, coord, array, false, 0, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_read
{
};

template <typename T, access a>
struct _texture1d_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord, ushort array, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort coord, ushort array, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint coord, uint array, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint coord, uint array, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_1d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture1d_array_write
{
};

template <typename T, access a>
struct _texture1d_array_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord, ushort array, ushort lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort coord, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord, uint array, uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_write_texture_1d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint coord, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_1d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};


template <typename T, access a, typename _Enable = void>
struct _texture1d_array
{
};

template <typename T, access a>
struct _texture1d_array<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture1d_array<T, a>>
  , _texture1d_array_sample<T, a>
  , _texture1d_array_read<T, a>
  , _texture1d_array_write<T, a>
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture1d_array<T, a> &>(*this);
    __metal_fence_texture_1d_array_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data METAL_CONST_ARG(lod) METAL_ZERO_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_get_width_texture_1d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_1d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture1d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_1d_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture1d_array : _texture1d_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture1d_array'");

  texture1d_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture1d_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture1d_array() ray_data = delete;
#endif

  METAL_FUNC texture1d_array(const thread texture1d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const device texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const thread texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const device texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const thread texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const device texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) ray_data = default;
#endif
#endif

  thread texture1d_array &operator=(const thread texture1d_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture1d_array &operator=(const device texture1d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture1d_array &operator=(const constant texture1d_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture1d_array &operator=(const ray_data texture1d_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture1d_array &operator=(const object_data texture1d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d_array &operator=(const thread texture1d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d_array &operator=(const device texture1d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture1d_array &operator=(const constant texture1d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture1d_array &operator=(const ray_data texture1d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture1d_array &operator=(const object_data texture1d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const thread texture1d_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const device texture1d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const constant texture1d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const ray_data texture1d_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture1d_array &operator=(const object_data texture1d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const thread texture1d_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const device texture1d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const constant texture1d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const ray_data texture1d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture1d_array &operator=(const object_data texture1d_array &) object_data = delete;
#endif

private:
  __metal_texture_1d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d_array<T, a>);
#endif
  friend struct _texture1d_array_sample<T, a>;
  friend struct _texture1d_array_read<T, a>;
  friend struct _texture1d_array_write<T, a>;
  friend struct _texture1d_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture1d_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture1d_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture1d_array'");

  METAL_FUNC texture1d_array() thread : t(__metal_get_null_texture_1d_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array() constant : t(__metal_get_null_texture_1d_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array() ray_data : t(__metal_get_null_texture_1d_array_t()) {}
#endif

  METAL_FUNC texture1d_array(const thread texture1d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const device texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const thread texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const device texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const thread texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const device texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const constant texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const ray_data texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture1d_array(const object_data texture1d_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture1d_array &operator=(const thread texture1d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture1d_array &operator=(const device texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture1d_array &operator=(const constant texture1d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture1d_array &operator=(const ray_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture1d_array &operator=(const object_data texture1d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d_array &operator=(const thread texture1d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d_array &operator=(const device texture1d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture1d_array &operator=(const constant texture1d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture1d_array &operator=(const ray_data texture1d_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture1d_array &operator=(const object_data texture1d_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const thread texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const device texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const constant texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const ray_data texture1d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture1d_array &operator=(const object_data texture1d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const thread texture1d_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const device texture1d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const constant texture1d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const ray_data texture1d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture1d_array &operator=(const object_data texture1d_array &) object_data = default;
#endif

private:
  __metal_texture_1d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture1d_array<T, a>);
#endif
  friend struct _texture1d_array_sample<T, a>;
  friend struct _texture1d_array_read<T, a>;
  friend struct _texture1d_array_write<T, a>;
  friend struct _texture1d_array<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture2d_sample
{
};

template <typename T, access a>
struct _texture2d_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, gradient2d options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_read
{
};

template <typename T, access a>
struct _texture2d_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_read_texture_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_write
{
};

template <typename T, access a>
struct _texture2d_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_write_texture_2d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_gather
{
};

template <typename T, access a>
struct _texture2d_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0), component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_t(derived.t, s.val, coord, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};


template <typename T, access a, typename _Enable = void>
struct _texture2d
{
};

template <typename T, access a>
struct _texture2d<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture2d<T, a>>
  , _texture2d_sample<T, a>
  , _texture2d_read<T, a>
  , _texture2d_write<T, a>
  , _texture2d_gather<T, a>
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture2d<T, a> &>(*this);
    __metal_fence_texture_2d_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_get_width_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_get_height_texture_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture2d : _texture2d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d'");

  texture2d() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture2d() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture2d() ray_data = delete;
#endif

  METAL_FUNC texture2d(const thread texture2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const device texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const constant texture2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d(const object_data texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const thread texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const device texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const constant texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d(const object_data texture2d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const thread texture2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const device texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const constant texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const object_data texture2d &) ray_data = default;
#endif
#endif

  thread texture2d &operator=(const thread texture2d &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d &operator=(const device texture2d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d &operator=(const constant texture2d &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture2d &operator=(const ray_data texture2d &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture2d &operator=(const object_data texture2d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d &operator=(const thread texture2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d &operator=(const device texture2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d &operator=(const constant texture2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture2d &operator=(const ray_data texture2d &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture2d &operator=(const object_data texture2d &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const thread texture2d &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const device texture2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const constant texture2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const ray_data texture2d &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d &operator=(const object_data texture2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const thread texture2d &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const device texture2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const constant texture2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const ray_data texture2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d &operator=(const object_data texture2d &) object_data = delete;
#endif

private:
  __metal_texture_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d<T, a>);
#endif
  friend struct _texture2d_sample<T, a>;
  friend struct _texture2d_read<T, a>;
  friend struct _texture2d_write<T, a>;
  friend struct _texture2d_gather<T, a>;
  friend struct _texture2d<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture2d<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture2d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d'");

  METAL_FUNC texture2d() thread : t(__metal_get_null_texture_2d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d() constant : t(__metal_get_null_texture_2d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d() ray_data : t(__metal_get_null_texture_2d_t()) {}
#endif

  METAL_FUNC texture2d(const thread texture2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const device texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const constant texture2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d(const object_data texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const thread texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const device texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d(const constant texture2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d(const object_data texture2d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const thread texture2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const device texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const constant texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const ray_data texture2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d(const object_data texture2d &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture2d &operator=(const thread texture2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d &operator=(const device texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d &operator=(const constant texture2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture2d &operator=(const ray_data texture2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture2d &operator=(const object_data texture2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d &operator=(const thread texture2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d &operator=(const device texture2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d &operator=(const constant texture2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture2d &operator=(const ray_data texture2d &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture2d &operator=(const object_data texture2d &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const thread texture2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const device texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const constant texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const ray_data texture2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d &operator=(const object_data texture2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const thread texture2d &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const device texture2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const constant texture2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const ray_data texture2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d &operator=(const object_data texture2d &) object_data = default;
#endif

private:
  __metal_texture_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d<T, a>);
#endif
  friend struct _texture2d_sample<T, a>;
  friend struct _texture2d_read<T, a>;
  friend struct _texture2d_write<T, a>;
  friend struct _texture2d_gather<T, a>;
  friend struct _texture2d<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_sample
{
};

template <typename T, access a>
struct _texture2d_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_read
{
};

template <typename T, access a>
struct _texture2d_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_array_t(derived.t, coord, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_write
{
};

template <typename T, access a>
struct _texture2d_array_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_write_texture_2d_array_t(derived.t, coord, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_2d_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_array_gather
{
};

template <typename T, access a>
struct _texture2d_array_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const thread METAL_CONST_ARG(c)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const device METAL_CONST_ARG(c)
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const constant METAL_CONST_ARG(c)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0), component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_2d_array_t(derived.t, s.val, coord, array, true, offset, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};


template <typename T, access a, typename _Enable = void>
struct _texture2d_array
{
};

template <typename T, access a>
struct _texture2d_array<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture2d_array<T, a>>
  , _texture2d_array_sample<T, a>
  , _texture2d_array_read<T, a>
  , _texture2d_array_write<T, a>
  , _texture2d_array_gather<T, a>
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture2d_array<T, a> &>(*this);
    __metal_fence_texture_2d_array_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_2d_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture2d_array : _texture2d_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_array'");

  texture2d_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture2d_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture2d_array() ray_data = delete;
#endif

  METAL_FUNC texture2d_array(const thread texture2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const device texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const thread texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const device texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const thread texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const device texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) ray_data = default;
#endif
#endif

  thread texture2d_array &operator=(const thread texture2d_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_array &operator=(const device texture2d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_array &operator=(const constant texture2d_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture2d_array &operator=(const ray_data texture2d_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture2d_array &operator=(const object_data texture2d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_array &operator=(const thread texture2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_array &operator=(const device texture2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_array &operator=(const constant texture2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture2d_array &operator=(const ray_data texture2d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture2d_array &operator=(const object_data texture2d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const thread texture2d_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const device texture2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const constant texture2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const ray_data texture2d_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_array &operator=(const object_data texture2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const thread texture2d_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const device texture2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const constant texture2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const ray_data texture2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_array &operator=(const object_data texture2d_array &) object_data = delete;
#endif

private:
  __metal_texture_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_array<T, a>);
#endif
  friend struct _texture2d_array_sample<T, a>;
  friend struct _texture2d_array_read<T, a>;
  friend struct _texture2d_array_write<T, a>;
  friend struct _texture2d_array_gather<T, a>;
  friend struct _texture2d_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture2d_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture2d_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_array'");

  METAL_FUNC texture2d_array() thread : t(__metal_get_null_texture_2d_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array() constant : t(__metal_get_null_texture_2d_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array() ray_data : t(__metal_get_null_texture_2d_array_t()) {}
#endif

  METAL_FUNC texture2d_array(const thread texture2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const device texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const thread texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const device texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const thread texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const device texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const constant texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const ray_data texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_array(const object_data texture2d_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture2d_array &operator=(const thread texture2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_array &operator=(const device texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_array &operator=(const constant texture2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture2d_array &operator=(const ray_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture2d_array &operator=(const object_data texture2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_array &operator=(const thread texture2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_array &operator=(const device texture2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_array &operator=(const constant texture2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture2d_array &operator=(const ray_data texture2d_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture2d_array &operator=(const object_data texture2d_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const thread texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const device texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const constant texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const ray_data texture2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_array &operator=(const object_data texture2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const thread texture2d_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const device texture2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const constant texture2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const ray_data texture2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_array &operator=(const object_data texture2d_array &) object_data = default;
#endif

private:
  __metal_texture_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_array<T, a>);
#endif
  friend struct _texture2d_array_sample<T, a>;
  friend struct _texture2d_array_read<T, a>;
  friend struct _texture2d_array_write<T, a>;
  friend struct _texture2d_array_gather<T, a>;
  friend struct _texture2d_array<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texture3d_sample
{
};

template <typename T, access a>
struct _texture3d_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradient3d grad_options, min_lod_clamp min_lod_clamp_options, int3 offset = int3(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_3d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_3d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture3d_read
{
};

template <typename T, access a>
struct _texture3d_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort3 coord, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort3 coord, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint3 coord, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_read_texture_3d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint3 coord, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_3d_t(derived.t, coord, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif

};

template <typename T, access a, typename _Enable = void>
struct _texture3d_write
{
};

template <typename T, access a>
struct _texture3d_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{

#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort3 coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort3 coord, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint3 coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_write_texture_3d_t(derived.t, coord, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint3 coord, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_3d_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif

};


template <typename T, access a, typename _Enable = void>
struct _texture3d
{
};

template <typename T, access a>
struct _texture3d<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texture3d<T, a>>
  , _texture3d_sample<T, a>
  , _texture3d_read<T, a>
  , _texture3d_write<T, a>
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture3d<T, a> &>(*this);
    __metal_fence_texture_3d_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_get_width_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_get_height_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_depth(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_get_depth_texture_3d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture3d<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_3d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture3d : _texture3d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture3d'");

  texture3d() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture3d() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture3d() ray_data = delete;
#endif

  METAL_FUNC texture3d(const thread texture3d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const device texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const constant texture3d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture3d(const object_data texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const thread texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const device texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const constant texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture3d(const object_data texture3d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const thread texture3d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const device texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const constant texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const object_data texture3d &) ray_data = default;
#endif
#endif

  thread texture3d &operator=(const thread texture3d &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture3d &operator=(const device texture3d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture3d &operator=(const constant texture3d &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture3d &operator=(const ray_data texture3d &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture3d &operator=(const object_data texture3d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture3d &operator=(const thread texture3d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture3d &operator=(const device texture3d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture3d &operator=(const constant texture3d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture3d &operator=(const ray_data texture3d &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture3d &operator=(const object_data texture3d &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const thread texture3d &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const device texture3d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const constant texture3d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const ray_data texture3d &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture3d &operator=(const object_data texture3d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const thread texture3d &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const device texture3d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const constant texture3d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const ray_data texture3d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture3d &operator=(const object_data texture3d &) object_data = delete;
#endif

private:
  __metal_texture_3d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture3d<T, a>);
#endif
  friend struct _texture3d_sample<T, a>;
  friend struct _texture3d_read<T, a>;
  friend struct _texture3d_write<T, a>;
  friend struct _texture3d<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture3d<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture3d<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture3d'");

  METAL_FUNC texture3d() thread : t(__metal_get_null_texture_3d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d() constant : t(__metal_get_null_texture_3d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d() ray_data : t(__metal_get_null_texture_3d_t()) {}
#endif

  METAL_FUNC texture3d(const thread texture3d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const device texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const constant texture3d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture3d(const object_data texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const thread texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const device texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture3d(const constant texture3d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture3d(const object_data texture3d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const thread texture3d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const device texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const constant texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const ray_data texture3d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture3d(const object_data texture3d &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture3d &operator=(const thread texture3d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture3d &operator=(const device texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture3d &operator=(const constant texture3d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture3d &operator=(const ray_data texture3d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture3d &operator=(const object_data texture3d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture3d &operator=(const thread texture3d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture3d &operator=(const device texture3d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture3d &operator=(const constant texture3d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture3d &operator=(const ray_data texture3d &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture3d &operator=(const object_data texture3d &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const thread texture3d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const device texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const constant texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const ray_data texture3d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture3d &operator=(const object_data texture3d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const thread texture3d &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const device texture3d &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const constant texture3d &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const ray_data texture3d &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture3d &operator=(const object_data texture3d &) object_data = default;
#endif

private:
  __metal_texture_3d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture3d<T, a>);
#endif
  friend struct _texture3d_sample<T, a>;
  friend struct _texture3d_read<T, a>;
  friend struct _texture3d_write<T, a>;
  friend struct _texture3d<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texturecube_sample
{
};

template <typename T, access a>
struct _texturecube_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, level options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, level options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_read
{
};

#if defined(__HAVE_TEXTURE_CUBE_READ__)
template <typename T, access a>
struct _texturecube_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_t(derived.t, coord, face, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texturecube_write
{
};

#if defined(__HAVE_TEXTURE_CUBE_WRITE__)
template <typename T, access a>
struct _texturecube_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    __metal_write_texture_cube_t(derived.t, coord, face, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};
#endif

template <typename T, access a, typename _Enable = void>
struct _texturecube_gather
{
};

template <typename T, access a>
struct _texturecube_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const device METAL_CONST_ARG(c)
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const device METAL_CONST_ARG(c)
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_t(derived.t, s.val, coord, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube
{
};

template <typename T, access a>
struct _texturecube<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texturecube<T, a>>
  , _texturecube_sample<T, a>
  , _texturecube_read<T, a>
  , _texturecube_write<T, a>
  , _texturecube_gather<T, a>
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texturecube<T, a> &>(*this);
    __metal_fence_texture_cube_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_get_width_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_get_height_texture_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texturecube : _texturecube<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texturecube'");

  texturecube() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texturecube() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texturecube() ray_data = delete;
#endif

  METAL_FUNC texturecube(const thread texturecube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const device texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const constant texturecube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube(const object_data texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const thread texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const device texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const constant texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube(const object_data texturecube &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const thread texturecube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const device texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const constant texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const object_data texturecube &) ray_data = default;
#endif
#endif

  thread texturecube &operator=(const thread texturecube &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texturecube &operator=(const device texturecube &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texturecube &operator=(const constant texturecube &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texturecube &operator=(const ray_data texturecube &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texturecube &operator=(const object_data texturecube &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube &operator=(const thread texturecube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube &operator=(const device texturecube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube &operator=(const constant texturecube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texturecube &operator=(const ray_data texturecube &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texturecube &operator=(const object_data texturecube &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const thread texturecube &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const device texturecube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const constant texturecube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const ray_data texturecube &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube &operator=(const object_data texturecube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const thread texturecube &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const device texturecube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const constant texturecube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const ray_data texturecube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texturecube &operator=(const object_data texturecube &) object_data = delete;
#endif

private:
  __metal_texture_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube<T, a>);
#endif
  friend struct _texturecube_sample<T, a>;
  friend struct _texturecube_read<T, a>;
  friend struct _texturecube_write<T, a>;
  friend struct _texturecube_gather<T, a>;
  friend struct _texturecube<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texturecube<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texturecube<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texturecube'");

  METAL_FUNC texturecube() thread : t(__metal_get_null_texture_cube_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube() constant : t(__metal_get_null_texture_cube_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube() ray_data : t(__metal_get_null_texture_cube_t()) {}
#endif

  METAL_FUNC texturecube(const thread texturecube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const device texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const constant texturecube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube(const object_data texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const thread texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const device texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube(const constant texturecube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube(const object_data texturecube &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const thread texturecube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const device texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const constant texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const ray_data texturecube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube(const object_data texturecube &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texturecube &operator=(const thread texturecube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texturecube &operator=(const device texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texturecube &operator=(const constant texturecube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texturecube &operator=(const ray_data texturecube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texturecube &operator=(const object_data texturecube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube &operator=(const thread texturecube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube &operator=(const device texturecube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube &operator=(const constant texturecube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texturecube &operator=(const ray_data texturecube &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texturecube &operator=(const object_data texturecube &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const thread texturecube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const device texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const constant texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const ray_data texturecube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube &operator=(const object_data texturecube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const thread texturecube &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const device texturecube &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const constant texturecube &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const ray_data texturecube &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube &operator=(const object_data texturecube &) object_data = default;
#endif

private:
  __metal_texture_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube<T, a>);
#endif
  friend struct _texturecube_sample<T, a>;
  friend struct _texturecube_read<T, a>;
  friend struct _texturecube_write<T, a>;
  friend struct _texturecube_gather<T, a>;
  friend struct _texturecube<T, a>;
};
#endif

#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a, typename _Enable = void>
struct _texturecube_array_sample
{
};

template <typename T, access a>
struct _texturecube_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, level options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC vec<T, 4> sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, level options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_sample_texture_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_texture_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_array_read
{
};

template <typename T, access a>
struct _texturecube_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint face, uint array, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_array_write
{
};

template <typename T, access a>
struct _texturecube_array_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const thread METAL_VALID_LOD_ARG(lod)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const device METAL_VALID_LOD_ARG(lod)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const constant METAL_VALID_LOD_ARG(lod)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const ray_data METAL_VALID_LOD_ARG(lod)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
  METAL_FUNC void write(vec<T, 4> color, uint2 coord, uint face, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    __metal_write_texture_cube_array_t(derived.t, coord, face, array, color, lod, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_IMAGEBLOCKS__)
  template <typename E, typename L>
  METAL_FUNC typename enable_if<_is_valid_imageblock_slice_write(E, T)>::type write(imageblock_slice<E, L> slice, uint2 coord, uint face, uint array, uint lod = 0) const object_data METAL_VALID_LOD_ARG(lod)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    __metal_write_imageblock_slice_to_texture_cube_array_t(derived.t, slice._imgblkptr, slice._size_valid, slice._size, coord, face, array, lod, is_same_v<L, imageblock_layout_implicit>, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_array_gather
{
};

template <typename T, access a>
struct _texturecube_array_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const thread METAL_CONST_ARG(c)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const device METAL_CONST_ARG(c)
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const device METAL_CONST_ARG(c)
  {
    bool nack;
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const constant METAL_CONST_ARG(c)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const ray_data METAL_CONST_ARG(c)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array, component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array, component c = component::x) const object_data METAL_CONST_ARG(c)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_texture_cube_array_t(derived.t, s.val, coord, array, int(c), int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texturecube_array
{
};

template <typename T, access a>
struct _texturecube_array<T, a, typename enable_if<is_color_texture_channel<T>::value>::type>
  : _deleted_operators<texturecube_array<T, a>>
  , _texturecube_array_sample<T, a>
  , _texturecube_array_read<T, a>
  , _texturecube_array_write<T, a>
  , _texturecube_array_gather<T, a>
{
#if defined(__HAVE_TEXTURE_READWRITE__)
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texturecube_array<T, a> &>(*this);
    __metal_fence_texture_cube_array_t(derived.t);
  }
#endif
#endif

  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_get_width_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_get_height_texture_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_get_array_size_texture_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texturecube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_texture_cube_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texturecube_array : _texturecube_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texturecube_array'");

  texturecube_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texturecube_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texturecube_array() ray_data = delete;
#endif

  METAL_FUNC texturecube_array(const thread texturecube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const device texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const thread texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const device texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const thread texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const device texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) ray_data = default;
#endif
#endif

  thread texturecube_array &operator=(const thread texturecube_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texturecube_array &operator=(const device texturecube_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texturecube_array &operator=(const constant texturecube_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texturecube_array &operator=(const ray_data texturecube_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texturecube_array &operator=(const object_data texturecube_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube_array &operator=(const thread texturecube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube_array &operator=(const device texturecube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texturecube_array &operator=(const constant texturecube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texturecube_array &operator=(const ray_data texturecube_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texturecube_array &operator=(const object_data texturecube_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const thread texturecube_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const device texturecube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const constant texturecube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const ray_data texturecube_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texturecube_array &operator=(const object_data texturecube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const thread texturecube_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const device texturecube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const constant texturecube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const ray_data texturecube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texturecube_array &operator=(const object_data texturecube_array &) object_data = delete;
#endif

private:
  __metal_texture_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube_array<T, a>);
#endif
  friend struct _texturecube_array_sample<T, a>;
  friend struct _texturecube_array_read<T, a>;
  friend struct _texturecube_array_write<T, a>;
  friend struct _texturecube_array_gather<T, a>;
  friend struct _texturecube_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texturecube_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texturecube_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texturecube_array'");

  METAL_FUNC texturecube_array() thread : t(__metal_get_null_texture_cube_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array() constant : t(__metal_get_null_texture_cube_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array() ray_data : t(__metal_get_null_texture_cube_array_t()) {}
#endif

  METAL_FUNC texturecube_array(const thread texturecube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const device texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const thread texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const device texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const thread texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const device texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const constant texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const ray_data texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texturecube_array(const object_data texturecube_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texturecube_array &operator=(const thread texturecube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texturecube_array &operator=(const device texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texturecube_array &operator=(const constant texturecube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texturecube_array &operator=(const ray_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texturecube_array &operator=(const object_data texturecube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube_array &operator=(const thread texturecube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube_array &operator=(const device texturecube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texturecube_array &operator=(const constant texturecube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texturecube_array &operator=(const ray_data texturecube_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texturecube_array &operator=(const object_data texturecube_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const thread texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const device texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const constant texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const ray_data texturecube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texturecube_array &operator=(const object_data texturecube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const thread texturecube_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const device texturecube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const constant texturecube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const ray_data texturecube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texturecube_array &operator=(const object_data texturecube_array &) object_data = default;
#endif

private:
  __metal_texture_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texturecube_array<T, a>);
#endif
  friend struct _texturecube_array_sample<T, a>;
  friend struct _texturecube_array_read<T, a>;
  friend struct _texturecube_array_write<T, a>;
  friend struct _texturecube_array_gather<T, a>;
  friend struct _texturecube_array<T, a>;
};
#endif
#endif

template <typename T, access a, typename _Enable = void>
struct _texture2d_ms_read
{
};

template <typename T, access a>
struct _texture2d_ms_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_t(derived.t, coord, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_ms
{
};

template <typename T, access a>
struct _texture2d_ms<T, a, typename enable_if<is_color_texture_channel<T>::value && _is_valid_ms_access(a)>::type>
  : _deleted_operators<texture2d_ms<T, a>>
  , _texture2d_ms_read<T, a>
{
  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture2d_ms : _texture2d_ms<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_ms'");
  static_assert(_is_valid_ms_access(a), "invalid access value 'a' for 'texture2d_ms'");

  texture2d_ms() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture2d_ms() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture2d_ms() ray_data = delete;
#endif

  METAL_FUNC texture2d_ms(const thread texture2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const thread texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const thread texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) ray_data = default;
#endif
#endif

  thread texture2d_ms &operator=(const thread texture2d_ms &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_ms &operator=(const device texture2d_ms &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_ms &operator=(const constant texture2d_ms &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture2d_ms &operator=(const ray_data texture2d_ms &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture2d_ms &operator=(const object_data texture2d_ms &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms &operator=(const thread texture2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms &operator=(const device texture2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms &operator=(const constant texture2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture2d_ms &operator=(const ray_data texture2d_ms &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture2d_ms &operator=(const object_data texture2d_ms &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const thread texture2d_ms &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const device texture2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const constant texture2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const ray_data texture2d_ms &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms &operator=(const object_data texture2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const thread texture2d_ms &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const device texture2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const constant texture2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const ray_data texture2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_ms &operator=(const object_data texture2d_ms &) object_data = delete;
#endif

private:
  __metal_texture_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_ms<T, a>);
#endif
  friend struct _texture2d_ms_read<T, a>;
  friend struct _texture2d_ms<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture2d_ms<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture2d_ms<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_ms'");
  static_assert(_is_valid_ms_access(a), "invalid access value 'a' for 'texture2d_ms'");

  METAL_FUNC texture2d_ms() thread : t(__metal_get_null_texture_2d_ms_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms() constant : t(__metal_get_null_texture_2d_ms_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms() ray_data : t(__metal_get_null_texture_2d_ms_t()) {}
#endif

  METAL_FUNC texture2d_ms(const thread texture2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const thread texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const thread texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const device texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const constant texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const ray_data texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms(const object_data texture2d_ms &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture2d_ms &operator=(const thread texture2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_ms &operator=(const device texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_ms &operator=(const constant texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture2d_ms &operator=(const ray_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture2d_ms &operator=(const object_data texture2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms &operator=(const thread texture2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms &operator=(const device texture2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms &operator=(const constant texture2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture2d_ms &operator=(const ray_data texture2d_ms &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture2d_ms &operator=(const object_data texture2d_ms &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const thread texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const device texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const constant texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const ray_data texture2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms &operator=(const object_data texture2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const thread texture2d_ms &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const device texture2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const constant texture2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const ray_data texture2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms &operator=(const object_data texture2d_ms &) object_data = default;
#endif

private:
  __metal_texture_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_ms<T, a>);
#endif
  friend struct _texture2d_ms_read<T, a>;
  friend struct _texture2d_ms<T, a>;
};
#endif

#if defined(__HAVE_TEXTURE_2D_MS_ARRAY__)
template <typename T, access a, typename _Enable = void>
struct _texture2d_ms_array_read
{
};

template <typename T, access a>
struct _texture2d_ms_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort2 coord, ushort array, ushort sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(ushort2 coord, ushort array, ushort sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC vec<T, 4> read(uint2 coord, uint array, uint sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_read(uint2 coord, uint array, uint sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    vec<T, 4> v = __metal_read_texture_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack, vec<T, 4>());
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture2d_ms_array
{
};

template <typename T, access a>
struct _texture2d_ms_array<T, a, typename enable_if<is_color_texture_channel<T>::value && _is_valid_ms_access(a)>::type>
  : _deleted_operators<texture2d_ms_array<T, a>>
  , _texture2d_ms_array_read<T, a>
{
  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    const thread auto &derived = static_cast<const thread texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    const device auto &derived = static_cast<const device texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    const constant auto &derived = static_cast<const constant texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_width_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_height_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_texture_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_texture_2d_ms_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture2d_ms_array : _texture2d_ms_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_ms_array'");
  static_assert(_is_valid_ms_access(a), "invalid access value 'a' for 'texture2d_ms_array'");

  texture2d_ms_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture2d_ms_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture2d_ms_array() ray_data = delete;
#endif

  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) ray_data = default;
#endif
#endif

  thread texture2d_ms_array &operator=(const thread texture2d_ms_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_ms_array &operator=(const device texture2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture2d_ms_array &operator=(const constant texture2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture2d_ms_array &operator=(const object_data texture2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms_array &operator=(const thread texture2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms_array &operator=(const device texture2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture2d_ms_array &operator=(const constant texture2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture2d_ms_array &operator=(const object_data texture2d_ms_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const thread texture2d_ms_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const device texture2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const constant texture2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture2d_ms_array &operator=(const object_data texture2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const thread texture2d_ms_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const device texture2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const constant texture2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture2d_ms_array &operator=(const object_data texture2d_ms_array &) object_data = delete;
#endif

private:
  __metal_texture_2d_ms_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_ms_array<T, a>);
#endif
  friend struct _texture2d_ms_array_read<T, a>;
  friend struct _texture2d_ms_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture2d_ms_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture2d_ms_array<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture2d_ms_array'");
  static_assert(_is_valid_ms_access(a), "invalid access value 'a' for 'texture2d_ms_array'");

  METAL_FUNC texture2d_ms_array() thread : t(__metal_get_null_texture_2d_ms_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array() constant : t(__metal_get_null_texture_2d_ms_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array() ray_data : t(__metal_get_null_texture_2d_ms_array_t()) {}
#endif

  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const thread texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const device texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const constant texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const ray_data texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture2d_ms_array(const object_data texture2d_ms_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture2d_ms_array &operator=(const thread texture2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_ms_array &operator=(const device texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture2d_ms_array &operator=(const constant texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture2d_ms_array &operator=(const object_data texture2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms_array &operator=(const thread texture2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms_array &operator=(const device texture2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture2d_ms_array &operator=(const constant texture2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture2d_ms_array &operator=(const object_data texture2d_ms_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const thread texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const device texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const constant texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture2d_ms_array &operator=(const object_data texture2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const thread texture2d_ms_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const device texture2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const constant texture2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const ray_data texture2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture2d_ms_array &operator=(const object_data texture2d_ms_array &) object_data = default;
#endif

private:
  __metal_texture_2d_ms_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture2d_ms_array<T, a>);
#endif
  friend struct _texture2d_ms_array_read<T, a>;
  friend struct _texture2d_ms_array<T, a>;
};
#endif
#endif

#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a, typename _Enable = void>
struct _texture_buffer_read
{
};

template <typename T, access a>
struct _texture_buffer_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC vec<T, 4> read(ushort coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
  METAL_FUNC vec<T, 4> read(uint coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_read_texture_buffer_1d_t(derived.t, coord, int(a), static_cast<thread bool*>(nullptr), vec<T, 4>());
  }
#endif
};

template <typename T, access a, typename _Enable = void>
struct _texture_buffer_write
{
};

template <typename T, access a>
struct _texture_buffer_write<T, a, typename enable_if<_is_valid_write(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC void write(vec<T, 4> color, ushort coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
  METAL_FUNC void write(vec<T, 4> color, uint coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    __metal_write_texture_buffer_1d_t(derived.t, coord, color, int(a), __METAL_TEXTURE_WRITE_ROUNDING_MODE__);
  }
#endif
};


template <typename T, access a, typename _Enable = void>
struct _texture_buffer
{
};

template <typename T, access a>
struct _texture_buffer<T, a, typename enable_if<is_color_texture_channel<T>::value && _is_valid_texture_buffer_access(a)>::type>
  : _deleted_operators<texture_buffer<T, a>>
  , _texture_buffer_read<T, a>
  , _texture_buffer_write<T, a>
{
  METAL_FUNC void fence() thread
  {
    thread auto &derived = static_cast<thread texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() device
  {
    device auto &derived = static_cast<device texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC void fence() constant
  {
    constant auto &derived = static_cast<constant texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC void fence() ray_data
  {
    ray_data auto &derived = static_cast<ray_data texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC void fence() object_data
  {
    object_data auto &derived = static_cast<object_data texture_buffer<T, a> &>(*this);
    __metal_fence_texture_buffer_1d_t(derived.t);
  }
#endif

  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data texture_buffer<T, a> &>(*this);
    return __metal_get_width_texture_buffer_1d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct texture_buffer : _texture_buffer<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture_buffer'");
  static_assert(_is_valid_texture_buffer_access(a), "invalid access value 'a' for 'texture_buffer'");

  texture_buffer() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  texture_buffer() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  texture_buffer() ray_data = delete;
#endif

  METAL_FUNC texture_buffer(const thread texture_buffer &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const device texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const thread texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const device texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const thread texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const device texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) ray_data = default;
#endif
#endif

  thread texture_buffer &operator=(const thread texture_buffer &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture_buffer &operator=(const device texture_buffer &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread texture_buffer &operator=(const constant texture_buffer &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread texture_buffer &operator=(const ray_data texture_buffer &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread texture_buffer &operator=(const object_data texture_buffer &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture_buffer &operator=(const thread texture_buffer &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture_buffer &operator=(const device texture_buffer &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device texture_buffer &operator=(const constant texture_buffer &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device texture_buffer &operator=(const ray_data texture_buffer &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device texture_buffer &operator=(const object_data texture_buffer &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const thread texture_buffer &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const device texture_buffer &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const constant texture_buffer &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const ray_data texture_buffer &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data texture_buffer &operator=(const object_data texture_buffer &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const thread texture_buffer &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const device texture_buffer &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const constant texture_buffer &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const ray_data texture_buffer &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data texture_buffer &operator=(const object_data texture_buffer &) object_data = delete;
#endif

private:
  __metal_texture_buffer_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture_buffer<T, a>);
#endif
  friend struct _texture_buffer_read<T, a>;
  friend struct _texture_buffer_write<T, a>;
  friend struct _texture_buffer<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct texture_buffer<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _texture_buffer<T, a>
{
  static_assert(is_color_texture_channel<T>::value, "invalid channel type 'T' for 'texture_buffer'");
  static_assert(_is_valid_texture_buffer_access(a), "invalid access value 'a' for 'texture_buffer'");

  METAL_FUNC texture_buffer() thread : t(__metal_get_null_texture_buffer_1d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer() constant : t(__metal_get_null_texture_buffer_1d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer() ray_data : t(__metal_get_null_texture_buffer_1d_t()) {}
#endif

  METAL_FUNC texture_buffer(const thread texture_buffer &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const device texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const thread texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const device texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const thread texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const device texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const constant texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const ray_data texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC texture_buffer(const object_data texture_buffer &) ray_data = default;
#endif
#endif

  METAL_FUNC thread texture_buffer &operator=(const thread texture_buffer &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture_buffer &operator=(const device texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread texture_buffer &operator=(const constant texture_buffer &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread texture_buffer &operator=(const ray_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread texture_buffer &operator=(const object_data texture_buffer &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture_buffer &operator=(const thread texture_buffer &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture_buffer &operator=(const device texture_buffer &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device texture_buffer &operator=(const constant texture_buffer &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device texture_buffer &operator=(const ray_data texture_buffer &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device texture_buffer &operator=(const object_data texture_buffer &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const thread texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const device texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const constant texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const ray_data texture_buffer &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data texture_buffer &operator=(const object_data texture_buffer &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const thread texture_buffer &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const device texture_buffer &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const constant texture_buffer &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const ray_data texture_buffer &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data texture_buffer &operator=(const object_data texture_buffer &) object_data = default;
#endif

private:
  __metal_texture_buffer_1d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(texture_buffer<T, a>);
#endif
  friend struct _texture_buffer_read<T, a>;
  friend struct _texture_buffer_write<T, a>;
  friend struct _texture_buffer<T, a>;
};
#endif
#endif

template <typename T, access a, typename _Enable = void>
struct _depth2d_sample
{
};

template <typename T, access a>
struct _depth2d_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, level options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t(derived.t, s.val, coord, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_depth_2d_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LEVEL_ARG(options)
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LEVEL_ARG(options)
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LEVEL_ARG(options)
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, level options, int2 offset = int2(0)) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_read
{
};

template <typename T, access a>
struct _depth2d_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_read_depth_2d_t(derived.t, coord, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    T v = __metal_read_depth_2d_t(derived.t, coord, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_gather
{
};

template <typename T, access a>
struct _depth2d_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_t(derived.t, s.val, coord, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, float compare_value, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_t(derived.t, s.val, coord, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d
{
};

template <typename T, access a>
struct _depth2d<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depth2d<T, a>>
  , _depth2d_sample<T, a>
  , _depth2d_read<T, a>
  , _depth2d_gather<T, a>
{
  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_get_width_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_get_height_depth_2d_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depth2d : _depth2d<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d'");

  depth2d() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depth2d() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depth2d() ray_data = delete;
#endif

  METAL_FUNC depth2d(const thread depth2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const device depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const constant depth2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d(const object_data depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const thread depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const device depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const constant depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d(const object_data depth2d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const thread depth2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const device depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const constant depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const object_data depth2d &) ray_data = default;
#endif
#endif

  thread depth2d &operator=(const thread depth2d &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d &operator=(const device depth2d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d &operator=(const constant depth2d &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depth2d &operator=(const ray_data depth2d &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depth2d &operator=(const object_data depth2d &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d &operator=(const thread depth2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d &operator=(const device depth2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d &operator=(const constant depth2d &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depth2d &operator=(const ray_data depth2d &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depth2d &operator=(const object_data depth2d &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const thread depth2d &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const device depth2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const constant depth2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const ray_data depth2d &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d &operator=(const object_data depth2d &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const thread depth2d &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const device depth2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const constant depth2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const ray_data depth2d &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d &operator=(const object_data depth2d &) object_data = delete;
#endif

private:
  __metal_depth_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d<T, a>);
#endif
  friend struct _depth2d_sample<T, a>;
  friend struct _depth2d_read<T, a>;
  friend struct _depth2d_gather<T, a>;
  friend struct _depth2d<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depth2d<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depth2d<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d'");

  METAL_FUNC depth2d() thread : t(__metal_get_null_depth_2d_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d() constant : t(__metal_get_null_depth_2d_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d() ray_data : t(__metal_get_null_depth_2d_t()) {}
#endif

  METAL_FUNC depth2d(const thread depth2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const device depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const constant depth2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d(const object_data depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const thread depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const device depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d(const constant depth2d &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d(const object_data depth2d &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const thread depth2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const device depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const constant depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const ray_data depth2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d(const object_data depth2d &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depth2d &operator=(const thread depth2d &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d &operator=(const device depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d &operator=(const constant depth2d &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depth2d &operator=(const ray_data depth2d &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depth2d &operator=(const object_data depth2d &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d &operator=(const thread depth2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d &operator=(const device depth2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d &operator=(const constant depth2d &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depth2d &operator=(const ray_data depth2d &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depth2d &operator=(const object_data depth2d &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const thread depth2d &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const device depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const constant depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const ray_data depth2d &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d &operator=(const object_data depth2d &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const thread depth2d &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const device depth2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const constant depth2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const ray_data depth2d &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d &operator=(const object_data depth2d &) object_data = default;
#endif

private:
  __metal_depth_2d_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d<T, a>);
#endif
  friend struct _depth2d_sample<T, a>;
  friend struct _depth2d_read<T, a>;
  friend struct _depth2d_gather<T, a>;
  friend struct _depth2d<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _depth2d_array_sample
{
};

template <typename T, access a>
struct _depth2d_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, level options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float2 coord, uint array, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_depth_2d_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float2 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_2d_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LOD_ARG(options)
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const thread METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LOD_ARG(options)
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const device METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LOD_ARG(options)
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const constant METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const ray_data METAL_VALID_LOD_ARG(options)
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const ray_data METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const object_data METAL_VALID_LOD_ARG(options)
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, level options, int2 offset = int2(0)) const object_data METAL_VALID_LOD_ARG(options)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, min_lod_clamp options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, true, offset, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENT2D_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float2 coord, uint array, float compare_value, gradient2d grad_options, min_lod_clamp min_lod_clamp_options, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_2d_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_array_read
{
};

template <typename T, access a>
struct _depth2d_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_array_t(derived.t, coord, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_array_gather
{
};

template <typename T, access a>
struct _depth2d_array_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float2 coord, uint array, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_2d_array_t(derived.t, s.val, coord, array, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float2 coord, uint array, float compare_value, int2 offset = int2(0)) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_2d_array_t(derived.t, s.val, coord, array, compare_value, true, offset, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_array
{
};

template <typename T, access a>
struct _depth2d_array<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depth2d_array<T, a>>
  , _depth2d_array_sample<T, a>
  , _depth2d_array_read<T, a>
  , _depth2d_array_gather<T, a>
{
  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_2d_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depth2d_array : _depth2d_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_array'");

  depth2d_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depth2d_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depth2d_array() ray_data = delete;
#endif

  METAL_FUNC depth2d_array(const thread depth2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const device depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const thread depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const device depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const thread depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const device depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) ray_data = default;
#endif
#endif

  thread depth2d_array &operator=(const thread depth2d_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_array &operator=(const device depth2d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_array &operator=(const constant depth2d_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depth2d_array &operator=(const ray_data depth2d_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depth2d_array &operator=(const object_data depth2d_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_array &operator=(const thread depth2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_array &operator=(const device depth2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_array &operator=(const constant depth2d_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depth2d_array &operator=(const ray_data depth2d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depth2d_array &operator=(const object_data depth2d_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const thread depth2d_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const device depth2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const constant depth2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const ray_data depth2d_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_array &operator=(const object_data depth2d_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const thread depth2d_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const device depth2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const constant depth2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const ray_data depth2d_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_array &operator=(const object_data depth2d_array &) object_data = delete;
#endif

private:
  __metal_depth_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_array<T, a>);
#endif
  friend struct _depth2d_array_sample<T, a>;
  friend struct _depth2d_array_read<T, a>;
  friend struct _depth2d_array_gather<T, a>;
  friend struct _depth2d_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depth2d_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depth2d_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_array'");

  METAL_FUNC depth2d_array() thread : t(__metal_get_null_depth_2d_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array() constant : t(__metal_get_null_depth_2d_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array() ray_data : t(__metal_get_null_depth_2d_array_t()) {}
#endif

  METAL_FUNC depth2d_array(const thread depth2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const device depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const thread depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const device depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const thread depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const device depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const constant depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const ray_data depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_array(const object_data depth2d_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depth2d_array &operator=(const thread depth2d_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_array &operator=(const device depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_array &operator=(const constant depth2d_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depth2d_array &operator=(const ray_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depth2d_array &operator=(const object_data depth2d_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_array &operator=(const thread depth2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_array &operator=(const device depth2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_array &operator=(const constant depth2d_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depth2d_array &operator=(const ray_data depth2d_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depth2d_array &operator=(const object_data depth2d_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const thread depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const device depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const constant depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const ray_data depth2d_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_array &operator=(const object_data depth2d_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const thread depth2d_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const device depth2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const constant depth2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const ray_data depth2d_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_array &operator=(const object_data depth2d_array &) object_data = default;
#endif

private:
  __metal_depth_2d_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_array<T, a>);
#endif
  friend struct _depth2d_array_sample<T, a>;
  friend struct _depth2d_array_read<T, a>;
  friend struct _depth2d_array_gather<T, a>;
  friend struct _depth2d_array<T, a>;
};
#endif

template <typename T, access a, typename _Enable = void>
struct _depthcube_sample
{
};

template <typename T, access a>
struct _depthcube_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC T sample(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, level options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, level options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t(derived.t, s.val, coord, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_depth_cube_t_grad(derived.t, s.val, coord, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, level options) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, level options) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t(derived.t, s.val, coord, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_t_grad(derived.t, s.val, coord, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_read
{
};

template <typename T, access a>
struct _depthcube_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_DEPTH_CUBE_READ__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    T v = __metal_read_depth_cube_t(derived.t, coord, face, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_gather
{
};

template <typename T, access a>
struct _depthcube_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_t(derived.t, s.val, coord, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, float compare_value) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, float compare_value) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_t(derived.t, s.val, coord, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube
{
};

template <typename T, access a>
struct _depthcube<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depthcube<T, a>>
  , _depthcube_sample<T, a>
  , _depthcube_read<T, a>
  , _depthcube_gather<T, a>
{
  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_get_width_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_get_height_depth_cube_t(derived.t, lod);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depthcube : _depthcube<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depthcube'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depthcube'");

  depthcube() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depthcube() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depthcube() ray_data = delete;
#endif

  METAL_FUNC depthcube(const thread depthcube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const device depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const constant depthcube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube(const object_data depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const thread depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const device depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const constant depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube(const object_data depthcube &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const thread depthcube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const device depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const constant depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const object_data depthcube &) ray_data = default;
#endif
#endif

  thread depthcube &operator=(const thread depthcube &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depthcube &operator=(const device depthcube &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depthcube &operator=(const constant depthcube &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depthcube &operator=(const ray_data depthcube &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depthcube &operator=(const object_data depthcube &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube &operator=(const thread depthcube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube &operator=(const device depthcube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube &operator=(const constant depthcube &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depthcube &operator=(const ray_data depthcube &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depthcube &operator=(const object_data depthcube &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const thread depthcube &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const device depthcube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const constant depthcube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const ray_data depthcube &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube &operator=(const object_data depthcube &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const thread depthcube &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const device depthcube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const constant depthcube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const ray_data depthcube &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depthcube &operator=(const object_data depthcube &) object_data = delete;
#endif

private:
  __metal_depth_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube<T, a>);
#endif
  friend struct _depthcube_sample<T, a>;
  friend struct _depthcube_read<T, a>;
  friend struct _depthcube_gather<T, a>;
  friend struct _depthcube<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depthcube<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depthcube<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depthcube'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depthcube'");

  METAL_FUNC depthcube() thread : t(__metal_get_null_depth_cube_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube() constant : t(__metal_get_null_depth_cube_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube() ray_data : t(__metal_get_null_depth_cube_t()) {}
#endif

  METAL_FUNC depthcube(const thread depthcube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const device depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const constant depthcube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube(const object_data depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const thread depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const device depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube(const constant depthcube &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube(const object_data depthcube &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const thread depthcube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const device depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const constant depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const ray_data depthcube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube(const object_data depthcube &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depthcube &operator=(const thread depthcube &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depthcube &operator=(const device depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depthcube &operator=(const constant depthcube &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depthcube &operator=(const ray_data depthcube &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depthcube &operator=(const object_data depthcube &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube &operator=(const thread depthcube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube &operator=(const device depthcube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube &operator=(const constant depthcube &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depthcube &operator=(const ray_data depthcube &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depthcube &operator=(const object_data depthcube &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const thread depthcube &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const device depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const constant depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const ray_data depthcube &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube &operator=(const object_data depthcube &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const thread depthcube &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const device depthcube &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const constant depthcube &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const ray_data depthcube &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube &operator=(const object_data depthcube &) object_data = default;
#endif

private:
  __metal_depth_cube_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube<T, a>);
#endif
  friend struct _depthcube_sample<T, a>;
  friend struct _depthcube_read<T, a>;
  friend struct _depthcube_gather<T, a>;
  friend struct _depthcube<T, a>;
};
#endif

#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a, typename _Enable = void>
struct _depthcube_array_sample
{
};

template <typename T, access a>
struct _depthcube_array_sample<T, a, typename enable_if<_is_valid_sample(a)>::type>
{
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, level options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, level options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t(derived.t, s.val, coord, array, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample(sampler s, float3 coord, uint array, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_depth_cube_array_t_grad(derived.t, s.val, coord, array, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_CALCULATE_LOD__)
  METAL_FUNC float calculate_clamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_calculate_clamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
  METAL_FUNC float calculate_unclamped_lod(sampler s, float3 coord) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_calculate_unclamped_lod_depth_cube_array_t(derived.t, s.val, coord, int(a));
  }
#endif
#endif

  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const thread METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const device METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const constant METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const ray_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), static_cast<thread bool*>(nullptr));
  }
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#if defined(__HAVE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC T sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), static_cast<thread bool*>(nullptr));
  }
#endif
#endif
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, options.value, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#endif
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, level options) const object_data METAL_VALID_LEVEL_ARG(options)
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, true, options.lod, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, min_lod_clamp options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, 0.0f, options.value, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_BIAS_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, bias bias_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, false, bias_options.value, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, options.dPdx, options.dPdy, 0.0f, int(a), &nack);
    return {v, !nack};
  }
#if defined(__HAVE_MIN_LOD_CLAMP__) && defined(__HAVE_SPARSE_SAMPLE_COMPARE_GRADIENTCUBE_OVERLOAD__)
  METAL_FUNC sparse_color<T> sparse_sample_compare(sampler s, float3 coord, uint array, float compare_value, gradientcube grad_options, min_lod_clamp min_lod_clamp_options) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_sample_compare_depth_cube_array_t_grad(derived.t, s.val, coord, array, compare_value, grad_options.dPdx, grad_options.dPdy, min_lod_clamp_options.value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_array_read
{
};

template <typename T, access a>
struct _depthcube_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort face, ushort array, ushort lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint face, uint array, uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint face, uint array, uint lod = 0) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    T v = __metal_read_depth_cube_array_t(derived.t, coord, face, array, lod, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_array_gather
{
};

template <typename T, access a>
struct _depthcube_array_gather<T, a, typename enable_if<_is_valid_gather(a)>::type>
{
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather(sampler s, float3 coord, uint array) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather(sampler s, float3 coord, uint array) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_depth_cube_array_t(derived.t, s.val, coord, array, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif

  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC vec<T, 4> gather_compare(sampler s, float3 coord, uint array, float compare_value) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<vec<T, 4>> sparse_gather_compare(sampler s, float3 coord, uint array, float compare_value) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    vec<T, 4> v = __metal_gather_compare_depth_cube_array_t(derived.t, s.val, coord, array, compare_value, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depthcube_array
{
};

template <typename T, access a>
struct _depthcube_array<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depthcube_array<T, a>>
  , _depthcube_array_sample<T, a>
  , _depthcube_array_read<T, a>
  , _depthcube_array_gather<T, a>
{
  METAL_FUNC uint get_width(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const thread
  {
    const thread auto &derived = static_cast<const thread depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const device
  {
    const device auto &derived = static_cast<const device depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const constant
  {
    const constant auto &derived = static_cast<const constant depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_get_width_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_height(uint lod = 0) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_get_height_depth_cube_array_t(derived.t, lod);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_get_array_size_depth_cube_array_t(derived.t);
  }
  METAL_FUNC uint get_num_mip_levels() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depthcube_array<T, a> &>(*this);
    return __metal_get_num_mip_levels_depth_cube_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depthcube_array : _depthcube_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depthcube_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depthcube_array'");

  depthcube_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depthcube_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depthcube_array() ray_data = delete;
#endif

  METAL_FUNC depthcube_array(const thread depthcube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const device depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const thread depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const device depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const thread depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const device depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) ray_data = default;
#endif
#endif

  thread depthcube_array &operator=(const thread depthcube_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depthcube_array &operator=(const device depthcube_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depthcube_array &operator=(const constant depthcube_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depthcube_array &operator=(const ray_data depthcube_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depthcube_array &operator=(const object_data depthcube_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube_array &operator=(const thread depthcube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube_array &operator=(const device depthcube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depthcube_array &operator=(const constant depthcube_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depthcube_array &operator=(const ray_data depthcube_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depthcube_array &operator=(const object_data depthcube_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const thread depthcube_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const device depthcube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const constant depthcube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const ray_data depthcube_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depthcube_array &operator=(const object_data depthcube_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const thread depthcube_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const device depthcube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const constant depthcube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const ray_data depthcube_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depthcube_array &operator=(const object_data depthcube_array &) object_data = delete;
#endif

private:
  __metal_depth_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube_array<T, a>);
#endif
  friend struct _depthcube_array_sample<T, a>;
  friend struct _depthcube_array_read<T, a>;
  friend struct _depthcube_array_gather<T, a>;
  friend struct _depthcube_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depthcube_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depthcube_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depthcube_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depthcube_array'");

  METAL_FUNC depthcube_array() thread : t(__metal_get_null_depth_cube_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array() constant : t(__metal_get_null_depth_cube_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array() ray_data : t(__metal_get_null_depth_cube_array_t()) {}
#endif

  METAL_FUNC depthcube_array(const thread depthcube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const device depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const thread depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const device depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const thread depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const device depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const constant depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const ray_data depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depthcube_array(const object_data depthcube_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depthcube_array &operator=(const thread depthcube_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depthcube_array &operator=(const device depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depthcube_array &operator=(const constant depthcube_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depthcube_array &operator=(const ray_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depthcube_array &operator=(const object_data depthcube_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube_array &operator=(const thread depthcube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube_array &operator=(const device depthcube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depthcube_array &operator=(const constant depthcube_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depthcube_array &operator=(const ray_data depthcube_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depthcube_array &operator=(const object_data depthcube_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const thread depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const device depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const constant depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const ray_data depthcube_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depthcube_array &operator=(const object_data depthcube_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const thread depthcube_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const device depthcube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const constant depthcube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const ray_data depthcube_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depthcube_array &operator=(const object_data depthcube_array &) object_data = default;
#endif

private:
  __metal_depth_cube_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depthcube_array<T, a>);
#endif
  friend struct _depthcube_array_sample<T, a>;
  friend struct _depthcube_array_read<T, a>;
  friend struct _depthcube_array_gather<T, a>;
  friend struct _depthcube_array<T, a>;
};
#endif
#endif

template <typename T, access a, typename _Enable = void>
struct _depth2d_ms_read
{
};

template <typename T, access a>
struct _depth2d_ms_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_t(derived.t, coord, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_ms
{
};

template <typename T, access a>
struct _depth2d_ms<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depth2d_ms<T, a>>
  , _depth2d_ms_read<T, a>
{
  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_height() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depth2d_ms : _depth2d_ms<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_ms'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_ms'");

  depth2d_ms() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depth2d_ms() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depth2d_ms() ray_data = delete;
#endif

  METAL_FUNC depth2d_ms(const thread depth2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const thread depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const thread depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) ray_data = default;
#endif
#endif

  thread depth2d_ms &operator=(const thread depth2d_ms &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_ms &operator=(const device depth2d_ms &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_ms &operator=(const constant depth2d_ms &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depth2d_ms &operator=(const ray_data depth2d_ms &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depth2d_ms &operator=(const object_data depth2d_ms &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms &operator=(const thread depth2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms &operator=(const device depth2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms &operator=(const constant depth2d_ms &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depth2d_ms &operator=(const ray_data depth2d_ms &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depth2d_ms &operator=(const object_data depth2d_ms &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const thread depth2d_ms &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const device depth2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const constant depth2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const ray_data depth2d_ms &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms &operator=(const object_data depth2d_ms &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const thread depth2d_ms &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const device depth2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const constant depth2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const ray_data depth2d_ms &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_ms &operator=(const object_data depth2d_ms &) object_data = delete;
#endif

private:
  __metal_depth_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_ms<T, a>);
#endif
  friend struct _depth2d_ms_read<T, a>;
  friend struct _depth2d_ms<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depth2d_ms<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depth2d_ms<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_ms'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_ms'");

  METAL_FUNC depth2d_ms() thread : t(__metal_get_null_depth_2d_ms_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms() constant : t(__metal_get_null_depth_2d_ms_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms() ray_data : t(__metal_get_null_depth_2d_ms_t()) {}
#endif

  METAL_FUNC depth2d_ms(const thread depth2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const thread depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const thread depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const device depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const constant depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const ray_data depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms(const object_data depth2d_ms &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depth2d_ms &operator=(const thread depth2d_ms &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_ms &operator=(const device depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_ms &operator=(const constant depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depth2d_ms &operator=(const ray_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depth2d_ms &operator=(const object_data depth2d_ms &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms &operator=(const thread depth2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms &operator=(const device depth2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms &operator=(const constant depth2d_ms &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depth2d_ms &operator=(const ray_data depth2d_ms &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depth2d_ms &operator=(const object_data depth2d_ms &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const thread depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const device depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const constant depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const ray_data depth2d_ms &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms &operator=(const object_data depth2d_ms &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const thread depth2d_ms &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const device depth2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const constant depth2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const ray_data depth2d_ms &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms &operator=(const object_data depth2d_ms &) object_data = default;
#endif

private:
  __metal_depth_2d_ms_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_ms<T, a>);
#endif
  friend struct _depth2d_ms_read<T, a>;
  friend struct _depth2d_ms<T, a>;
};
#endif

#if defined(__HAVE_DEPTH_2D_MS_ARRAY__)
template <typename T, access a, typename _Enable = void>
struct _depth2d_ms_array_read
{
};

template <typename T, access a>
struct _depth2d_ms_array_read<T, a, typename enable_if<_is_valid_read(a)>::type>
{
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const thread
  {
    bool nack;
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const device
  {
    bool nack;
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const constant
  {
    bool nack;
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const ray_data
  {
    bool nack;
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_16B_COORDS__)
  METAL_FUNC T read(ushort2 coord, ushort array, ushort sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(ushort2 coord, ushort array, ushort sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
  METAL_FUNC T read(uint2 coord, uint array, uint sample) const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), static_cast<thread bool*>(nullptr));
  }
#if defined(__HAVE_SPARSE_TEXTURES__)
  METAL_FUNC sparse_color<T> sparse_read(uint2 coord, uint array, uint sample) const object_data
  {
    bool nack;
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    T v = __metal_read_depth_2d_ms_array_t(derived.t, coord, array, sample, int(a), &nack);
    return {v, !nack};
  }
#endif
#endif
};

template <typename T, access a, typename _Enable = void>
struct _depth2d_ms_array
{
};

template <typename T, access a>
struct _depth2d_ms_array<T, a, typename enable_if<is_depth_texture_channel<T>::value && _is_valid_depth_access(a)>::type>
  : _deleted_operators<depth2d_ms_array<T, a>>
  , _depth2d_ms_array_read<T, a>
{
  METAL_FUNC uint get_width() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const thread
  {
    const thread auto &derived = static_cast<const thread depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const device
  {
    const device auto &derived = static_cast<const device depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC uint get_width() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const constant
  {
    const constant auto &derived = static_cast<const constant depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC uint get_width() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const ray_data
  {
    const ray_data auto &derived = static_cast<const ray_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC uint get_width() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_width_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_height() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_height_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_array_size() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_array_size_depth_2d_ms_array_t(derived.t);
  }
  METAL_FUNC uint get_num_samples() const object_data
  {
    const object_data auto &derived = static_cast<const object_data depth2d_ms_array<T, a> &>(*this);
    return __metal_get_num_samples_depth_2d_ms_array_t(derived.t);
  }
#endif
};

template <typename T, access a, typename _Enable>
struct depth2d_ms_array : _depth2d_ms_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_ms_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_ms_array'");

  depth2d_ms_array() thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  depth2d_ms_array() constant = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  depth2d_ms_array() ray_data = delete;
#endif

  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) ray_data = default;
#endif
#endif

  thread depth2d_ms_array &operator=(const thread depth2d_ms_array &) thread = delete;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_ms_array &operator=(const device depth2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  thread depth2d_ms_array &operator=(const constant depth2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_RAYTRACING__)
  thread depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_MESH__)
  thread depth2d_ms_array &operator=(const object_data depth2d_ms_array &) thread = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms_array &operator=(const thread depth2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms_array &operator=(const device depth2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  device depth2d_ms_array &operator=(const constant depth2d_ms_array &) device = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  device depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) device = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  device depth2d_ms_array &operator=(const object_data depth2d_ms_array &) device = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const thread depth2d_ms_array &) ray_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const device depth2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const constant depth2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) ray_data = delete;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  ray_data depth2d_ms_array &operator=(const object_data depth2d_ms_array &) ray_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const thread depth2d_ms_array &) object_data = delete;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const device depth2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const constant depth2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) object_data = delete;
#endif
#endif
#if defined(__HAVE_MESH__)
  object_data depth2d_ms_array &operator=(const object_data depth2d_ms_array &) object_data = delete;
#endif

private:
  __metal_depth_2d_ms_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_ms_array<T, a>);
#endif
  friend struct _depth2d_ms_array_read<T, a>;
  friend struct _depth2d_ms_array<T, a>;
};

#if defined(__HAVE_DEFAULT_CONSTRUCTABLE_TEXTURE__) && defined(__HAVE_COPY_ASSIGNABLE_TEXTURE__)
template <typename T, access a>
struct depth2d_ms_array<T, a, typename enable_if<_is_valid_default_construct(a) && _is_valid_copy_assign(a)>::type> : _depth2d_ms_array<T, a>
{
  static_assert(is_depth_texture_channel<T>::value, "invalid channel type 'T' for 'depth2d_ms_array'");
  static_assert(_is_valid_depth_access(a), "invalid access value 'a' for 'depth2d_ms_array'");

  METAL_FUNC depth2d_ms_array() thread : t(__metal_get_null_depth_2d_ms_array_t()) {}
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array() constant : t(__metal_get_null_depth_2d_ms_array_t()) {}
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array() ray_data : t(__metal_get_null_depth_2d_ms_array_t()) {}
#endif

  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) constant = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) constant = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const thread depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const device depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const constant depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const ray_data depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC depth2d_ms_array(const object_data depth2d_ms_array &) ray_data = default;
#endif
#endif

  METAL_FUNC thread depth2d_ms_array &operator=(const thread depth2d_ms_array &) thread = default;
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_ms_array &operator=(const device depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC thread depth2d_ms_array &operator=(const constant depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC thread depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC thread depth2d_ms_array &operator=(const object_data depth2d_ms_array &) thread = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms_array &operator=(const thread depth2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms_array &operator=(const device depth2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
  METAL_FUNC device depth2d_ms_array &operator=(const constant depth2d_ms_array &) device = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC device depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) device = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC device depth2d_ms_array &operator=(const object_data depth2d_ms_array &) device = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const thread depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const device depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const constant depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) ray_data = default;
#endif
#if defined(__HAVE_MESH__)
#if defined(__HAVE_RAYTRACING__)
  METAL_FUNC ray_data depth2d_ms_array &operator=(const object_data depth2d_ms_array &) ray_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const thread depth2d_ms_array &) object_data = default;
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const device depth2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_INDIRECT_ARGUMENT_BUFFER__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const constant depth2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_RAYTRACING__)
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const ray_data depth2d_ms_array &) object_data = default;
#endif
#endif
#if defined(__HAVE_MESH__)
  METAL_FUNC object_data depth2d_ms_array &operator=(const object_data depth2d_ms_array &) object_data = default;
#endif

private:
  __metal_depth_2d_ms_array_t t;

#if defined(__HAVE_NULL_TEXTURE__)
  friend METAL_FUNC bool metal::is_null_texture<T, a>(depth2d_ms_array<T, a>);
#endif
  friend struct _depth2d_ms_array_read<T, a>;
  friend struct _depth2d_ms_array<T, a>;
};
#endif
#endif

#if defined(__HAVE_NULL_TEXTURE__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture1d<T, a> tex)
{
  return __metal_is_null_texture_1d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture1d_array<T, a> tex)
{
  return __metal_is_null_texture_1d_array_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d<T, a> tex)
{
  return __metal_is_null_texture_2d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d_array<T, a> tex)
{
  return __metal_is_null_texture_2d_array_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture3d<T, a> tex)
{
  return __metal_is_null_texture_3d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(texturecube<T, a> tex)
{
  return __metal_is_null_texture_cube_t(tex.t);
}
#if defined(__HAVE_TEXTURE_CUBE_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texturecube_array<T, a> tex)
{
  return __metal_is_null_texture_cube_array_t(tex.t);
}
#endif
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d_ms<T, a> tex)
{
  return __metal_is_null_texture_2d_ms_t(tex.t);
}
#if defined(__HAVE_TEXTURE_2D_MS_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture2d_ms_array<T, a> tex)
{
  return __metal_is_null_texture_2d_ms_array_t(tex.t);
}
#endif
#if defined(__HAVE_TEXTURE_BUFFER__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(texture_buffer<T, a> tex)
{
  return __metal_is_null_texture_buffer_1d_t(tex.t);
}
#endif
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d<T, a> tex)
{
  return __metal_is_null_depth_2d_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d_array<T, a> tex)
{
  return __metal_is_null_depth_2d_array_t(tex.t);
}
template <typename T, access a>
METAL_FUNC bool is_null_texture(depthcube<T, a> tex)
{
  return __metal_is_null_depth_cube_t(tex.t);
}
#if defined(__HAVE_DEPTH_CUBE_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(depthcube_array<T, a> tex)
{
  return __metal_is_null_depth_cube_array_t(tex.t);
}
#endif
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d_ms<T, a> tex)
{
  return __metal_is_null_depth_2d_ms_t(tex.t);
}
#if defined(__HAVE_DEPTH_2D_MS_ARRAY__)
template <typename T, access a>
METAL_FUNC bool is_null_texture(depth2d_ms_array<T, a> tex)
{
  return __metal_is_null_depth_2d_ms_array_t(tex.t);
}
#endif
#endif
} // namespace metal
#pragma METAL internals : disable

#endif // __METAL_TEXTURE
